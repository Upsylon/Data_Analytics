---
title: "Project Data Analytics"
author: "Bron Luca, Grandadam Patrik"
date: "`r format(Sys.time(), '%d %B, %Y')`"
bibliography: bibliography.bib
output:
  html_document:
    toc: true
    toc_float: true
---

 - [Introduction](#Intro)
 - [Exploratory analysis](#Exp)
    - [Explanatory variables](#Exp2)
    - [Response variables](#Exp3)
    - [Interactions between the explanatory variables and the response variable](#Exp4)
 - [Modelling](#Mod)
    - [CART](#CART)
    - [Neural Network](#NN)
    - [Support Vector Machine](#SVM)
    - [Random Forest](#RF)
    - [K-Nearest Neighbors](#KNN)
    - [Ensemble methods](#EM)
 - [Cross-validation Approach](#CV)
 - [Conclusion](#CCL)

```{r include = FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, message=FALSE, echo=FALSE}
cred <- read.csv2("GermanCredit.csv")
cred <- data.frame(cred)
attach(cred)
```


```{r, message=FALSE, echo=FALSE}
library(dplyr)
library(magrittr)
library(knitr)
library(kableExtra)
library(ggplot2)
library(stringr)
library(DataExplorer)
library(corrr)
library(rpart)
library(rpart.plot)
library(maptree)
library(caret)
library(e1071)
library(randomForest)
library(gmodels)
library(MASS)
library(nnet)
library(neuralnet)
library(NeuralNetTools)
library(kknn)
library(gbm)
```


```{r, echo=FALSE}
my_theme <- function(base_size = 10, base_family = "sans"){
  theme_minimal(base_size = base_size, base_family = base_family) +
    theme(
      axis.text = element_text(size = 10),
      axis.text.x = element_text(vjust = 0.5, hjust = 0.5),
      axis.title = element_text(size = 12),
      plot.title = element_text(hjust = 0.5),
      panel.grid.major = element_line(color = "grey"),
      panel.grid.minor = element_blank(),
      panel.background = element_rect(fill = "aliceblue"),
      strip.background = element_rect(fill = "lightgrey", color = "grey", size = 1),
      strip.text = element_text(face = "bold", size = 10, color = "black"),
      legend.position = "bottom",
      legend.justification = "top", 
      legend.box = "horizontal",
      legend.box.background = element_rect(colour = "grey50"),
      legend.background = element_blank(),
      panel.border = element_rect(color = "grey", fill = NA, size = 0.5)
    )
}
```

```{r, echo = FALSE}
names(cred) <- tolower(names(cred)) # changing the name of the variable into lowercase
cred <- cred[,-1] # deleting the first useless column
```

# Introduction {#Intro}

## Context
Our client is a financial institution who wants to use statistical methods and machine learning to improve their process.   
In this analysis, we aim at obtaining a model that may be used to determine if new applicants present a good or bad credit risk.
To do this, we have at our disposal the *German Credit data*. A dataset on 1000 past credit applicants, described by 30 variables. Each applicant is rated as Good or Bad.  
The task is therefore learning from those past data to build model that would correctly rate the new clients.

## Methodology

In order to propose an optimal model that could be used for predictions, we begin with an explanatory analysis to better understand our dataset. Based on it, we will already be able to have some assumptions about which variables might be the most important ones.
Then, we continue with the modelling part. To present a decent amount of details, we first use different models that we present extensively, using a train set / test set approach to be able to compute the accuracy. Then, we tune them using a cross-validation for selecting the best parameters.  
Thus, we are able to prune the trees, select the best costs for SVM, the number of neurones and decay for the neural network, the K for the K-Nearest Neighboor etc.
Furthermore, using a cross-validation approach on the previously tuned models, we put all of them into competition to be able to select the model that, considering our dataset, leads to the best predictions.   
Finally, we come with some conclusions and recommendations for our client. 

# Exploratory analysis {#Exp}

## Explanatory variables {#Exp2}

### Overview 

Before beginning any kind of analysis, we have to understand the data we are working with. 

First, we check if there is missing values.

```{r}
sum(is.na(cred)) # checking if we have missing data
```

As stated by the client, there is no missing values.  
Then, we get a first glance at the data.

```{r, echo = FALSE}
data.frame(variable = names(cred),
           classe = sapply(cred, typeof),
           first_values = sapply(cred, 
                                 function(x) paste0(head(x),  collapse = ", ")),
           row.names = NULL) %>% 
  kable(caption="Overview of our data") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F) %>%
  column_spec(1, width = "10em", border_right = T) %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "18em") %>%
  scroll_box(width = "65%", height = "250px")
```


&nbsp;

As we can see, the data are coherent with the infos that the client provided us. Most of them are binary or categorical, while only few are numerical.

More than just seeing the first values of our variables and their types, we also need to understand how distributed they are and their links with the response variable.  

We can appreciate the summary of the different variables. The summary and frequency table of *history* are presented below as an example:  

```{r, echo=FALSE}
c(summary(cred$history)) %>% 
  as.data.frame %>%
  kable(caption = "Summary of variable history", 
        align = "l", col.names = c("Value")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "float_left"
  )

table(cred$history) %>% 
  kable(caption = "Frequency table of history",
        col.names = c("Values", "Frequency")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F
  )
```
&nbsp;

However, presenting such a summary for all variables can be long and boring. It can be better to represent these number visually. A boxplot is optimal to get all the important values for the numerical data, while a barplot will give us strong insights for categorical data. Let's appreciate the following graphs:  

```{r, fig.height=3, fig.width=3, warning=FALSE, cache=TRUE, echo = FALSE}

for (i in 1:(length(cred)-1)) {
  if (range(cred[, i] < 5)) {
    print(
      ggplot(cred, aes(x = cred[, i])) +
        geom_bar(stat = "count", position = "dodge") +
        ggtitle(str_c("Barplot of\n", paste(
          colnames(cred[i])
        ))) +
        xlab(colnames(cred[i])) +
        ylab("Total") +
        my_theme()
    )
  } else
  {
    print(
      ggplot(cred, aes(y = cred[, i])) + geom_boxplot() +
        ylab(colnames(cred[i])) +
        ggtitle(str_c("Boxplot of\n ", paste(
          colnames(cred[i])
        ))) +
        my_theme() +
        theme(
          axis.text.x=element_blank())
    )
  }
}

```

Thanks to these graphs, we can better understand our data at a glance and will be able to refer to them when needed.  

In addition, these graphs enable us too see that some data are not tidy. For instance, *education* should be a binary variable. However, we can see on the histogram of this variable that we have data where $-1$ was recorded. We have the same problem for the binary variable *guarantor* were a value $2$ is present.  
In addition, we can also have strong suspicions that the variable *age* was a wrongly recorded data as we can see an outlier with a value much bigger than 100.  
We will have to confirm our first assumptions and to modify these dirty data in an appropriate way.  

Let's first look at our variable *age*. We assume that, generally, a person will not live more than a hundred year, and will not contract a credit at such age. This is why the data with $Age > 100$ are most likely wrongly recorded. We will therefore have to replace them in our database.  

First, we have to find how much data are potentially dirty according to our assumptions and to localise them in order to replace them.  


```{r, echo=FALSE}
attach(cred)
```

```{r, echo=FALSE}
table(age >= 100) %>% kable(caption = "Number of instances with age > 100") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F, position = "float_left") %>%
  column_spec(1, width = "5em", border_right = T) %>%
  column_spec(2, width = "5em")
which(age > 100) %>% kable(caption="Position of instance with age > 100") %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F, position = "left") %>%
  column_spec(1, width = "9.5em") 
```
&nbsp;

According to our results, we have one data with $age > 100$ that has to be replaced. It is the instance `r which(age>100) ` and its value is `r age[which(age>100)]`.  

We can consider different options to replace this value. The first one could be to replace it by a value at random within the range (a value at random between `r min(age)`  and `r max(age[age!=max(age)])`, which is the second lowest value after $125$).  
However, according to the following histogram, the distribution of the age (without the erroneous data) is inequal with a concentration around small values (which is logical as young people generally have less money than elders and therefore are more subject to ask for credits).   

```{r, fig.height=4, fig.width=4, message=FALSE, warning=FALSE, echo=FALSE}
ggplot(cred, aes(x = cred$age)) + 
  geom_bar(stat = "count", position = "dodge") +
  ggtitle(str_c("Barplot of age without the erroneous data")) +
  xlab("Age") +
  ylab("Frequency") +
  xlim(c(min(age),max(age[age!=max(cred$age)]))) +
  my_theme()
```

It could therefore be possible to replace it at random with different probabilities according to the size of each class.  
We prefer to opt for the median (equal to `r median(age[age!=max(age)])`) to replace our problematic value as it offers more convenience.  
Note that for calculating the median, our problematic value should not be used.  

```{r, eval = FALSE}
# we do not run this code after a discussion with the client
cred$age[which(age>75)] <- median(age[age!=max(age)])
```

An alternative could have been to use the mean, but, as we have no really big outlier, both values would have been close to each other ($mean = `r mean(age)`$ while $median = `r median(age)`$). 

<hr>  

Next, we also have to deal with our two binary data that have been wrongly recorded:  
    - one in *education*  
    - one in *guarantor*

They also have to be cleaned.  

The following is again the barplot of *education*.  

```{r, fig.height=4, fig.width=4, echo=FALSE}
ggplot(cred, aes(x = cred$education)) +
  geom_bar(stat = "count", position = "dodge") +
  ggtitle(str_c("Barplot of education")) +
  xlab("Education") +
  ylab("Count") +
  my_theme()
```

Here, the likelihood that this wrongly recorded data is equal to $0$ is clearly higher. Therefore, each of the previously presented methods (using the mean, using the median and even assigning it to a class at random) would, with a high probability, result in assigning the most likely instance and thus assigning it the value $Education = 0$.  
We can confirm these first assumption with a frequency table:  

```{r, echo=FALSE}
edu <- rbind(table(education), 
             paste(round(prop.table(table(education)) * 100, 1), "%"))
rownames(edu) <- c("sample size", "proportion")
edu %>% kable(caption = "Frequency table of education", align = 'c') %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F) %>%
  column_spec(1, border_right = T)
```

&nbsp;

It is indeed more appropriate to replace our value by 0 as the probability of belonging to this class is close to 20 times bigger.  

```{r, eval = FALSE}
# we do not run this code after a discussion with the client
cred$education[which(education == -1)] <- 0 
```

<hr>

Concerning the variable *guarantor*, we can look at the frequency table and plot the barplot as well: 

```{r, echo = FALSE}
gua <- rbind(table(guarantor), 
             paste(round(prop.table(table(guarantor)) * 100, 1), "%"))
rownames(gua) <- c("sample size", "proportion")
gua %>% kable(caption = "Frequency table of guarantor", align = 'c') %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F, position = "float_left") %>%
  column_spec(1, border_right = T) %>%
  column_spec(2, width="5em") %>%
  column_spec(3, width="5em") 
```


```{r, fig.height=3, fig.width=3, echo=FALSE}
ggplot(cred, aes(x = cred$guarantor)) +
  geom_bar(stat = "count", position = "dodge") +
  ggtitle(str_c("Barplot of guarantor")) +
  xlab("Guarantor") +
  ylab("Count") +
  scale_x_continuous(breaks = c(0, 1, 2)) +
  my_theme()
```

Again, for the same reasons, it is preferable to replace the wrongly recorded data by 0.  

```{r, eval = FALSE}
# we do not run this code after a discussion with the client
cred$guarantor[which(guarantor == 2)] <- 0
```

<hr>

Finding the most likely replacement value comes from the idea that we try to find a replacement value which is going to be the least disruptive possible so that it does no interfere with the modelling that will be done later.  
However, this methodonly works if we have a big enough dataset such that the corrected value will not have a big impact if its replacement value is far from the observed one. Though, it will never be as good as asking directly what is the real value of the erroneous data and that is why we called our client to ask what they were.  
He told us that:  
$Age = 75 / Education = 1 / Guarantor = 1$  

```{r}
cred$age[which(age>75)] <- median(age[age!=max(age)])
cred$education[which(education == -1)] <- 1
cred$guarantor[which(guarantor == 2)] <- 1
```

<hr>

In addition, the variable *present_resident* is also problematic as it doesn't have the same range as the other categorical values. Its range goes from `r min(range(present_resident))` to `r max(range(present_resident))` whereas it should go from 0 to 3 like the other ones. We can modifiy its values in order to have the same format everywhere.
 
```{r}
cred$present_resident <- subtract(cred$present_resident, 1)
```

<hr>

These first steps have enabled us to better understand our explanatory variables and to clean the problematic ones.  
We now have to focus in detail to the response variable on which the predictions should be made.   
 
## Response variable {#Exp3}

As our final goal is to predict if a customer should be classified as a risky one or not, we have to have a particular look at our response variable that establishes if an applicant presents a good or a bad risk.  
Let's first have a look at its distribution:  

```{r, echo=FALSE}

ggplot(cred, aes(x = cred$response)) + 
  geom_bar(stat = "count", position = "dodge") +
  ggtitle(str_c("Barplot of the response variable")) +
  xlab("Response variable") +
  ylab("Observations") +
  my_theme()
```

```{r, echo=FALSE}
cred$response <- as.factor(ifelse(cred$response == 1, "good", "bad"))

res <- rbind(table(response), 
             paste(round(prop.table(table(response)) * 100, 1), "%"))
rownames(res) <- c("sample size", "proportion")
res %>% kable(caption = "Frequency table of our response variable", 
              align = 'c') %>% 
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"), 
                full_width = F) %>%
  column_spec(1, border_right = T) %>%
  column_spec(2, width="5em") %>%
  column_spec(3, width="5em") 
```

As we can see, if a random customer steps in the bank, the *a priori* probability that he will present a good ranking will be of 70%.  
Without any calculations, the bank has more chances to be octroying a credit to a person that will not default.  
However, the consequences can be really dramatic if 30% of the credits that the bank gives are not totally reimbursed. That's why we have to develop a model to improve this initial accuracy that is obtained using a naive method of always octroying a credit.   
Optimally, this model should also minimise the number of credits that are predicted as "good" and that are actually "bad" as the consequences for the bank (reimbursement of the credit by the customer) can be much more dramatic in this situation than in a situation where a "good" credit is predicted as "bad".  

We will talk about this later. First, after having presented each variables, it could be interesting to see if we can already have some assumptions concerning the relations between the explanatory variables and the response variable.

## Interactions between the explanatory variables and the response variable {#Exp4}

As already said, to better understand the link between the explanatory variable and the response variable, we can make multiple plot their respective interactions. It is possible to have first assumption of their behavior and to have guesses about their significiance.  
We build boxplot for numerical variables and barplots for the rest.

 
```{r, fig.width=3, fig.height=3, cache=TRUE, echo=FALSE, warning = FALSE}
for (i in 1:(length(cred)-1)) {
  if (range(cred[, i] < 5)) {
    print(
      ggplot(cred, aes(
      x = cred[, i],  fill = response
    )) +
      geom_bar(position = "fill") +
      xlab("Response variable") +
      ylab(colnames(cred[i])) +
      ggtitle(str_c(
        "Interaction between\n ",
        paste(colnames(cred[i]), "and the\n response variable")
      )) +
      my_theme()
    )
  } else
  {
    print(
      ggplot(cred, aes(
      x = response, y = cred[, i],  group = response
    )) +
      geom_boxplot() +
      xlab("Response variable") +
      ylab(colnames(cred[i])) +
      ggtitle(str_c(
        "Interaction between\n ",
        paste(colnames(cred[i]), "and the\n response variable")
      )) +
      my_theme()
    )
  }
}
```

Based on these graphs, we can already have first insights about which variables might impact the response variable. One the one hand, the boxplots are generally not well separated. Most of the size of the box are overlapping when comparing the response variables which means it is hard to discriminate them according to their response variable. On the other hand, when the bars of the barplots display different proportions like for the variable *chk_acct*, we might conclude that the variable will be important in our analysis as it well discriminates the response. However, we can not take any conclusion about the importance of variables when the barplots does not display significant differences of proportions of "good" and "bad". 

At this point, we already have some hints of what variables would matter in our analysis and therefore be able to remove the most unimpactful from our analysis, but since the model that we use have good methods to finding the right variables, we keep them all in case it could improve their predictions capacities.


# Modelling {#Mod}

Many variables are observed factors, but are being processed as interger in the dataframe. Encoding the factor variables as factor will ease the analysis.

```{r}
for (i in 1:(length(cred)-1)) {
  if (range(cred[, i])[2] - range(cred[, i])[1] < 5) {
    cred[, i] <- cred[, i] %>% as.character %>% as.factor
  }
}
```

We can again look at our data to check if the categorical variables were indeed changed as factors.

```{r}
str(cred)
```

Before beginning to work on our different models, we can create a test set and a training set in order to build the models. This procedure is used in order to avoid overfitting and to predict instances which have been used while building the model.  
We opt for a size of 70% of the original dataset for the training set and a size of 30% of the original dataset for the testing set.  
In order to evaluate the performance of the different models, we will have to use the exact **same training and test sets** for each model to be sure that the performance differences will result from the model we use and not from the randomess of splitting differently both sets.   
A cross-validation will be performed at the end in order to compare the different models and to choose which one should be used to make good predictions.  

```{r}
# Creation of testing and training sets
set.seed(123) 
index.train <- createDataPartition(y = cred$response, p = 0.7, list = FALSE)
cred.train <- cred[index.train,]
cred.test <- cred[-index.train,]
```


In addition, to evaluate our models, we will use the accuracy as main measure of performance. However, computing the accuracy for each model can be quite long. We prefer to build a function to be able to retrieve it at any time based on a confusion matrix:  


```{r}
# Creating of a function to retrieve the accuracy from a confusion matrix
accuracy <- function(c){
  print(sum(diag(c)) / sum(c))
}
```

We can now begin to work on the different models that we will use in order to make our predictions.  

## CART {#CART}

First, we begin our analysis by using a decision (classification) tree.   

The goal of a decision tree is to predict the final class of our response variable ("good" or "bad") by using a succession of binary rules to apply to our data.   
Each node is created thanks to an algorithm that aims to minimize an impurity criterion. The feature and its underlying value that maximises the impurity reduction (that "best splits" the dataset in two) will be selected. This procedure is repeated until a stopping rule is reached. At the end, we will have multiple branches that will all lead to the final forecast that we will make for a given instance.  
Better than words, let's compute the model and have a look at it!  

### Building the model

```{r}
cart.model <- rpart(response ~ .,  data = cred.train, method = "class")
```

```{r}
rpart.plot(cart.model, main = "Original decision tree")
```

At this time, we have obtained a decision tree that can be used to do the predictions. At its nodes, one should look at the values of the data and take the appropriate direction till arriving at the last row, when the prediction can be made.  
However, this tree is also really complex: there are a lot of splits and branches.
We have to tune this initial model and make it more simple. We will simplify this model without loosing  predictive capabilities by pruning it, keeping only the most important splits linked to the most important variables.  

### Tuning the model: Pruning

As already said, our complex tree has to be pruned in order to reduce its complexity. To do so, we will use the *1 - SE rule*.   
The idea of this rule is really general. As one would establish a t-test in statistics to see if two measures are *statistically different*, the *1 - SE rule* tries to establish if two models produce statistically different results (if we can affirm that one outperforms the other).  
We therefore consider the *xerror* (the criterion in which we are interested in and that we want to minimize) and its standard deviation *xstd*. A models that falls within 1 standard deviation of the most accurate model can be considered as equivalent in term of performance. Therefore, using this rule, we will be able to prune the tree to get a much simpler model, without loosing in quality as the performance capability of our new model will be *statistically not different* as the first one.  
To select the size of our pruned tree, we will look at the xerror of the most accurate tree. We will then select the simplest tree with an xerror that lies within the calculated interval of it.

Let's have a look at these values from our original tree and decide where to prune it.

```{r, echo=FALSE, fig.height=5, fig.width=5}
cart.model$cptable %>% 
  kable(caption = "CP table of the CART model") %>% 
  kable_styling(
  bootstrap_options = c("striped", "hover", "condensed"),
  full_width = F, 
  position = "float_left"
)
head(cart.model$variable.importance, n = 6) %>%
  kable(caption = "Variable importance table first 6 instances") %>% 
  kable_styling(
  bootstrap_options = c("striped", "hover", "condensed"),
  full_width = F
) %>%
  column_spec(1, width = "10em") %>%
  column_spec(2, width = "10em")

plotcp(cart.model)
```


```{r, echo = FALSE}
# xstd associated with lowest xerror
min.xstd <- cart.model$cptable[which.min(
  cart.model$cptable[,ncol(cart.model$cptable) -1]),
  ncol(cart.model$cptable)]

# lowest xerror
min.xerror <- cart.model$cptable[which.min(
  cart.model$cptable[,ncol(cart.model$cptable) -1]),
  ncol(cart.model$cptable) - 1]

sum.xe.xstd <- min.xstd + min.xerror # sum of both

# CP value to which to prune the tree ; 
# min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd)) 
# representing the row to be pruned at : 
cp.pruned <- 
  cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] 
                                < sum.xe.xstd))), 1]
```
 
Accoring to our first table, the minimal *xerror* is equal to `r cart.model$cptable[which.min(cart.model$cptable[,ncol(cart.model$cptable) -1]), ncol(cart.model$cptable) - 1]`, the minimal *xstd* to `r cart.model$cptable[which.min(cart.model$cptable[,ncol(cart.model$cptable) -1]), ncol(cart.model$cptable)]` and the sum of both is therefore equal to `r sum.xe.xstd`.  

The smallest tree with an xerror below this value is equal to `r cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd))), ncol(cart.model$cptable) - 1]` and we will therefore prune the tree at CP = `r cp.pruned`. According to our previous table, this represents `r cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd))), 2]  ` splits to be kept, equivalent to a tree of size `r cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd))), 2] + 1  `.  
It is also possible to observe this value on the graph where the dash line indicates the *xerror* plus its *xstd* from the most accurate tree. We therefore select the less complex tree under this line, which is the tree of size `r cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd))),2] + 1  ` (or, again, the one with `r cart.model$cptable[(min(which(cart.model$cptable[,ncol(cart.model$cptable) -1] < sum.xe.xstd))),2]  ` splits).  

We thus prune the tree at this value (the *R* function requires to indicate CP.)

```{r}
cart.pruned <- prune(cart.model, cp = cp.pruned)
```

```{r, echo=FALSE}
rpart.plot(cart.pruned, main = "Pruned decision tree")
```

We can visualize this new pruned tree that is much smaller and therefore less complex than our original one and will use it to do our predictions, to build the confusion matrix and to calculate the underlying accuracy.  

### Predicting the values of the testing set

Now, we will use the model to predict the values of the testing set.  

```{r, comment = NA}
pred.cart <- predict(cart.pruned, newdata = cred.test, type = "class")
```

Then, we can appreciate the following confusion matrix of the model.  

```{r, echo = FALSE, comment = NA}
cart.tab <- table(Predictions = pred.cart, Observations = cred.test$response) 
cart.tab %>% kable(caption = "Confusion matrix for the CART model",
                   col.names = c("Predict bad", "Predict good")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l") %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```

Based on this table, we can calculate the accuracy using our previously build function, and that calculates the element well classified divided by the total number of elements.  

```{r}
# accuracy using our previously build function
accuracy(cart.tab) 
```

It is possible to have more informaion, with for instance the sum of each rows with the following cross table.

```{r comment=NA, echo=FALSE, fig.height=3, fig.width=3}
CrossTable(x = cred.test$response, y = pred.cart, prop.chisq = FALSE)
```

We can see that `r cart.tab[1,1] + cart.tab[2,1]` are predicated as bad and `r cart.tab[1,2] + cart.tab[2,2]` are predicted as good.  

## Neural Network {#NN}

### Building the model and optimizing it: selecting the number of neurones in the hidden layer
We know look at another model: the Neural Network.

Some litterature suggests that "one should never use more than two hidden layers and that, for many practical problems, there is no reason to use any more than one hidden layer". @heaton2008introduction.


In addition, "over-parametrization quickly lead to instability in the estimate and can lead to overfitting. One possibility is to impose a penalty on the largest weights during the optimization. This is called regularization and, more specifically in the context of neural network, weight decay." @boldi. Thus, the model that we are going to train will be a 1 layer Neural Network to which we will simulate different number of neurones and decay. The final model that we are going to choose will be the one that maximises the accuracy using a 5-fold cross-validation. 

For the following models, we will create a new variable to be able to easily to this cross-validation

```{r, results = "hide"}
train_control <- trainControl(method = "cv", number = 5)
```

We can now build the Neural Network.

```{r, results = "hide"}
nnet_fit <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = expand.grid(size = 14:25, decay = c(1.0, 1.5, 2)),
                 MaxNWts = 3000,
                 trace = FALSE,
                 method = "nnet")

```

Actually, multiple models have been built with the different *sizes* and *decay* considered. Thus, 36 models have been created (number of different size multiplied by number of tested decay). Among all these models, we will have to select the best one. We tune the model meaning that we plot the accuracy resulting from the different models according to the different sizes and decay tested. We then select the size and decay that maximise the accuracy.  

```{r}
plot(nnet_fit)
nnet_fit$results
nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$size # the size maximizing the accuracy
nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$decay # the decay maximizing the accuracy
```

### Model selection and predicting the values of the testing set

We present you the characteristics of the model retained, with `r nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$size` neurones in the hidden layer and a decay of `r nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$decay` which maximises the accuracy using a 5 fold cross-validation. 
As usual, we trained the model and predict the values of the test set to be able to build the confusion matrix and to calculate the accuracy.  

```{r, results = 'hide'}
nnet.model.retained <- 
  nnet(cred.train$response ~ .,
       data = cred.train, 
       maxit = 200,
       MaxNWts = 3000,
       trace = FALSE,
       size = nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$size, 
       decay = nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$decay)

# Predictions on the test set:
pred.nnet.retained <- predict(nnet.model.retained, cred.test, type="class") 

# Confusion matrix
tab.nnet.retained <- table(Reality = cred.test$response, 
                           Predicted = unlist(pred.nnet.retained)) 
# Accuracy
acc.nnet.retained <- sum(ifelse(
  cred.test$response == unlist(pred.nnet.retained), 1, 0), na.rm = TRUE) /
  length(cred.test$response) 
```

In addition, we can plot our retained neural network:

```{r, comment = NA, fig.width=10, fig.height=10, echo=FALSE}
# plot
plotnet(nnet.model.retained, 
        alpha_val = 0.1,
        circle_col = "steelblue1", 
        pos_col = "blue", 
        neg_col = "red", 
        bord_col = "black", 
        pad_x = 0.8)
```

This graph shows that our model can be quite complex, there are plenty of arrows. It is not necessary to understand precisely all of them and they can be seen as a "black box", meaning that the interpretability of such a model is modest. But, afterall, what we need is to make good predictions!


```{r, echo=FALSE}
# confusion matrix
tab.nnet.retained %>% kable(
  caption = "Confusion matrix of the fitted NNET model",
  col.names = c("Predict good", "Predict bad")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l"
  ) %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```

We obtain a final accuracy of `r round(acc.nnet.retained,3)` on our testing set. 
Note that this accuracy is different from the one using the cross-validation before. Here, we use only one test set that may be disproportioned. We will, at the end, use again a cross-validation for all models on the same train and test sets in order to compare the different models.  


## Support Vector Machine {#SVM}

Another important model that we will now consider and compare to the other ones will be the Support Vector Machine.  
This models aims at separating the feature space into higher dimensions, it searches for the linear optimal separating hyperplane (@Zuber) creating multiple spaces associated with the prediction of the different categories of the outcome variable (in our case, "good" and "bad"). 

### Building the model

Again, we decide to use the *caret* package to be able to compare models with different costs. We will then select the best performing model and analyse it separately.  

```{r}
svm_parameters <- data.frame(C = seq(0.5, 5, 0.5))
# note that we first tested a wider scope of values (from 0 to 1000)
# and now present only the interval that leads to the best results

svm_fit <- train(form = response ~ .,
                   data = cred,
                   method = "svmRadialCost",
                   tuneGrid = svm_parameters,
                   preProcess = "range",
                   trace = FALSE,
                   trControl = train_control)
```

### Optimizing the model: selecting good cost parameter

Now that our different SVM models with different cost parameters have been built, we have to select the cost parameter that leads to the highest accuracy.

```{r}
plot(svm_fit)

svm_fit$results
svm_fit$results[which.max(svm_fit$results$Accuracy),]$C # the cost maximizing the accuracy
```


According to our results and by having tested different costs, we conclude that we should opt for a cost of `r svm_fit$results[which.max(svm_fit$results$Accuracy),]$C` which leads to the highest accuracy.  



We can then "extract" this model and analyze it on his own. We have to note that, like the Neural Network, SVM doesn't allow for much interpretations. What matters here is the quality of the predictions more than the individual interpretability of the different variables. In addition, to have a 2D graph, one should fix (slice) all other variables. Here, having 30 explanative variables, it does not make sense to fix 28 out of them and plotting is therefore not appropriate.  

However, we can look at the predictions of the model.

### Predicting the values of the testing set

```{r}
svm.model.retained <- 
  svm(cred.train$response ~ .,
       data = cred.train, 
       cost = svm_fit$results[which.max(svm_fit$results$Accuracy),]$C)

# Predictions on the test set:
pred.svm.retained <- predict(svm.model.retained, cred.test, type = "class")

# Confusion matrix
tab.svm.retained <- table(Reality = cred.test$response, 
                           Predicted = unlist(pred.svm.retained)) 
# Accuracy
acc.svm.retained <- accuracy(tab.svm.retained) 
```

We can build the confusion matrix and see how the model performs.

```{r, echo = FALSE}
tab.svm.retained %>% kable(
  caption = "Confusion matrix of the fitted SVM model",
  col.names = c("Predict good", "Predict bad")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l"
  ) %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```

With this model we obtain a final accuracy of `r acc.svm.retained` on the original testing set that we built at the beginning (without CV).  
Again, we will compare this model with the others in a final step using a cross-validation procedure performed on the same training sets and testing sets at the end of our analysis. 


## K - Nearest Neighbors {#KNN}

### Building the model and Optimizing the model: selecting the number of neighbors and the distance measure

The following code will not be run each time we execute our evaluation of the different models in order to gain in computing efficiency (we have "*eval = FALSE*").  
However, we ran it once to be able to evaluate which distance measure to select.  

```{r, eval = FALSE}
knn_parameters <- expand.grid(kmax = 2:30, distance = 1:5, kernel = "optimal")

knn_fit <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = knn_parameters,
                 method = "kknn",
                 preProcess = c("center", "scale"))
plot(kknn_fit)
kknn_fit$results

kknn_fit$results[which.max(knn_fit$results$Accuracy),]$k
kknn_fit$results[which.max(knn_fit$results$Accuracy),]$distance
```

After having created multiple K-Nearest Neighbors models with the knn function, we realize that the distance of 2 outperforms other distances. We can therefore use the function knn to illustrate how our final model is built and how we select k (note that *knn* function is more efficient in term of computationnal power, only reason why we use it to choose k rather than the *kknn* function just above). 

We can thus use the *knn* function to see how the accuracy varies with different k between 2 an 30 and select the number of neighbors that lead to the highest accuracy. 

```{r}
knn_parameters <- expand.grid(k = 2:30)

knn_fit <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = knn_parameters,
                 method = "knn",
                 preProcess = c("center", "scale"))
plot(knn_fit)
knn_fit$results

knn_fit$results[which.max(knn_fit$results$Accuracy),]$k
```

The selected knn model uses a distance of 2 and is computed with the `r knn_fit$results[which.max(knn_fit$results$Accuracy),]$k` nearest neighbors. The obtained accuracy using a 5 fold cross-Validation is equal to `r max(knn_fit$results$Accuracy)`. 

### Predicting the values of the testing set

```{r, comment = NA, echo = FALSE}
pred.knn <- predict(knn_fit, newdata = cred.test)

# confusion matrix
knn.tab <- table(Predictions = pred.knn, Observations = cred.test$response) 
cart.tab %>% kable(caption = "Confusion matrix for the K-NN model",
                   col.names = c("Predict bad", "Predict good")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l") %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```

Given our confusion matrix, on our initial testing set, the obtained accuracy is equal to `r accuracy(knn.tab)`. 




## Ensemble methods {#EM}

Ensemble contains several learners (so called base learners or sub-learners) which are combined to build one learner called an ensemble learner. Taken individually, each learner has a poor predictive power.  
However, the strength of ensemble methods lies in the fact that the final prediction will combine the results of each of these so-called *poor* models to create one final predictions that should outperforms usual prediction methods. Indeed, *overestimated* prediction will be compensated by *underestimated* prediction which will result in a final prediction that should be in average better than using only a regular model. 

We will consider two ensemble methods: the random forest and the boosting.


### Random Forest {#RF}

The first ensemble method that we will consider is the Random Forest. Considering its construction, the Random Forest is a really special model.  
Indeed, the model is consisting in building a lot of trees with predictions that will be averaged to produce a final prediction.  
In the random forest, the models will consist of many different trees with a set of features drawn at random at each split of the trees when growing them. In practice, the original data is split into a training and a testing set and M new training set of the same size as the original training set are built randomly (with replacement) from the original testing set. Then, on each training set, a tree is built with a random selection of variables used at each split. The final prediction will be the most predicted class based on all these small learners.  


A central reason of the efficiency of random forest is that the models predictions should be **uncorrelated**. Since all the models are in principle good, this uncorrelation will bring **stability** to the final prediction. For Random Forest, a consequence of forcing the exclusion of some features in some splits in some models is that the range of features used in the final prediction is enlarged (compared to a global model that uses only few features). This gives more chance for extrapolation outside the training set. @boldi


The goal of this process to built many small uncorrelated learners rather than one unique big learner to increase the predictive power of the model.  

Using our caret package again as our most powerful tool enabling to build an easy and readable code, we will test different *mtry* which correspond to number of variables that we consider at each split of the tree. Therefore, at each split, we consider only some variables (while in a regular CART model, we consider all of them), what will lead the different trees to be uncorrelated and increase their prediction power. All other splitting concerns are handled directly with caret.  

Finally, we will select the *mtry* that leads to the highest accuracy.  

```{r}
rf_parameters <- data.frame(mtry = c(7:18))
# note that we first tested a wider scope of values (from 0 to 1000 with bigger
# increments) and now present only the interval that leads to the best results

rf_fit <- train(form = response ~ .,
                 data = cred,
                 method = "rf",
                 ntree = 200, 
                 tuneGrid = rf_parameters,
                 preProcess = "range",
                 trace = FALSE,
                 trControl = train_control)
```

Now that we have built our model, we can select the optimal mtry to continue our analysis.  

```{r}
plot(rf_fit) 

rf_fit$results
rf_fit$results[which.max(rf_fit$results$Accuracy),]$mtry # the cost maximizing the accuracy
```

According to these results, we see that we should consider  `r rf_fit$results[which.max(rf_fit$results$Accuracy),]$mtry` variables at each split, which leads to the highest accuracy.

We can now analyse more in depth this model.

```{r}
rf.model.retained <- 
  randomForest(formula = response ~ .,
               data = cred.train, 
               ntree = 200, 
               tuneGrid = data.frame(
                 mtry = rf_fit$results[which.max(svm_fit$results$Accuracy),]$mtry),
               importance = TRUE)
```


Note that we decide not to make *ntree* var, the number of trees used in the Random Forest. This number has been set to 200. This is the first number we tried and increasing it more would have a quasi null impact. We can verify this assumption thanks to the following graph that let us see that the errors become stable.


```{r}
plot(rf.model.retained)
```


We see that the error rate remains really similar past a certain value (around 100), meaning that increasing the number of tree does not allow to increase the predictive capabilities anymore. The second derivative is negative and the decrease of the error rate becomes smaller and smaller the more trees we add. We therefore decide to stick to this initial value of 200 trees which is larger than 100 to have some margin.

<hr>

Now that we have built our final model, contrarily to the regular CART, we can not directly see which variables are the most important looking at the branches of each tree.  

Unlike for the Neural Network or SVM, it is still possible to see the individual contribution of each variables thanks to the variable importance plot.
It is still possible to see the individual contribution of each variables thanks to the variable importance plot.  
One is based on the average decrease in impurity a variable provides, the other is based on how bad the prediction becomes if the variable is shuffled. An important variable will in average decrease a lot the impurity of a tree either because it is often selected or because each time it provides a good split.   Also, if the variable is important, giving to the model an incorrect value of this variable should decrease a lot the prediction quality.  
Therefore, in the following graph, the important variables are on the first lines of the graph and confirm what we have already assumed previously in our analysis concerning the important variables.


```{r}
varImpPlot(rf.model.retained) 
```


Finally, we can predict the values of our testing set, build the confusion matrix and predict the accuracy. 

```{r}
# Predictions on the test set:
pred.rf.retained <- predict(rf.model.retained, cred.test, type = "class") 

# Confusion matrix
tab.rf.retained <- table(Reality = cred.test$response, 
                           Predicted = unlist(pred.rf.retained)) 
# Accuracy
acc.rf.retained <- accuracy(tab.rf.retained)
```

```{r, echo = FALSE}
tab.rf.retained %>% kable(
  caption = "Confusion matrix of the fitted RF model",
  col.names = c("Predict good", "Predict bad")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l"
  ) %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```

Using the Random Forest, we obtain a final accuracy of `r acc.rf.retained` on the original testing set. 


### Boosting

The second ensemble method that we consider is boosting. Again, the goal of using this technique is to increase the predictive power of the learners. It consists of constructing a separate decision tree at each iteration of the process with the goal to improve and improve the fitted trees at each iteration. In the end, the prediction will be the one that will be the most predicted by the different trees in average.  

We begin by using, as usual, the caret package and create a grid to test different values for the parameters. Using a cross-validation procedure, we will then select the parameters that lead to the highest accuracy. 

```{r, results = 'hide', comments = NA}
boo_parameters <- expand.grid(n.trees = c(3500, 4000, 4500), 
                              shrinkage = c(0.001, 0.01, 0.02), 
                              interaction.depth = 1,
                              n.minobsinnode = 10)
# We considered first more different parameters and the one presented are the ones 
# that might best fit the data.

boo_fit <- train(form = response ~ .,
                 data = cred,
                 method = "gbm",
                 tuneGrid = boo_parameters,
                 trControl = train_control)
```

The models with the different parameters have been trained and tested on their respective test set. The accuracy has been recorded for each parameters and we can view it thanks to the following graph:  


```{r}
plot(boo_fit)
```

According to this graph, we should select `r boo_fit$results[which.max(boo_fit$results$Accuracy),]$n.trees` trees and a shrinkage of `r boo_fit$results[which.max(boo_fit$results$Accuracy),]$shrinkage`.  

Using these parameters, we can compute the corresponding model with the *gbm* function (Generalized Boosted Regression Modeling) and explore it more in details.  

```{r}
boo.model.retained <- gbm(as.numeric(cred$response)-1 ~., 
               data = cred, 
               distribution = "adaboost",
               shrinkage = boo_fit$results[which.max(boo_fit$results$Accuracy),]$shrinkage,
               n.trees = boo_fit$results[which.max(boo_fit$results$Accuracy),]$n.trees)
```

Using this model, we can predict the instances of the testing set and build the corresponding confusion matrix.

```{r}
# Predictions on the test set:
pred.boo.retained <- ifelse(
  predict(boo.model.retained, 
          cred.test, 
          n.trees = boo_fit$results[which.max(boo_fit$results$Accuracy),]$n.trees,
          type = "response") > 0.5, "good", "bad")

# Confusion matrix
tab.boo.retained <- table(Reality = cred.test$response, 
                           Predicted = pred.boo.retained) 
```

```{r, echo = FALSE}
tab.boo.retained %>% kable(
  caption = "Confusion matrix of the fitted boosting model",
  col.names = c("Predict good", "Predict bad")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "l"
  ) %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em")
```


The boosting presents a quite high accuracy of `r accuracy(tab.boo.retained)` compared to the previous models. However, this accuracy has been built only on one unique testing set. We will later use a cross-validation appoach to see if this accuracy is robust when using multiple different training and testing sets.  





# Cross-validation approach {#CV}

At this point, let's make a summary of the situation.  
Until now, we have built several different models and we have tuned them (selected their parameters), so the different models that we have are *the best SVM*, *the best Neural Network*, etc.  
However, we still have to confront each model to be able to select the *overall winner*.  
In order to be able to compare them, we will not evaluate them only on a testing as evaluating the performance of the model once will not enable us to make any conclusions. For instance, if the concerned testing set is disproportionned, we could attribute the good score of a model to the predictive capabilities of the model while it comes in fact from the good fit of the method with the test set. To be sure that the score of the model are not impacted (too much) by the characteristics of the testing set, we will perform a 10-fold cross-validation.  
With this technique, we will use 10 different training set and 10 different testing sets. Our original dataset will be split in 10, using at each iteration 1/10 of the original dataset as a testing set and the rest as a training set. Using this method, each instance will be once (and exactly once) in the testing set.  
We will then be able to compute the accuracy on the different testing set for each iteration of the cross-validation and then evaluate the average accuracy which will represent the numbers that we can expect the model to classify correctly.  

We will first make the whole procedure "manually" as an example and then use the famous *caret* package again to make the code as simple as possible.  

Thus, we begin with a creation of 10 different sets in order to do the cross-validation. The number of instances being `r nrow(cred)`, we will make 10 sets of size `r nrow(cred)/10`. They are stored in a list named test.list. At each step, the remaining part of the data base is stored in the list train.test.  

```{r}
test.list <- list() # creates an empty list that will be the test sets
train.list <- list() # creates an empty list that will be the train sets
counter <- 0

# Creates the 10 sets of size 300
for (i in 1:10){
  index <- counter + c(1:100) # the row numbers that will be in the test set
  test.list[[i]] <- cred[index, ] # the test set number i
  train.list[[i]] <- cred[-index, ] # the train set number i
  counter <- counter + 100
}
```

For example, *test.list[[1]]* is a data set of 300 rows taken at random from our data.

```{r, echo = FALSE} 
test.list[[1]] %>% kable(caption="Our first test set named test.list[[1]]") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F) %>%
  scroll_box(width = "100%", height = "200px")


train.list[[1]] %>% kable(caption="Train set associated with test.list[[1]]") %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed"),
                full_width = F) %>%
  scroll_box(width = "100%", height = "200px")
```

<br>
As already stated, we first make the whole procedure on one model before using the caret package.  
We choose to present in details the CART model tuned and pruned. We have already built our 10 different training set and we will use them to make the predictions and calculate the accuracy of our 10 testing set. 

### CART Model

```{r, results = 'hide', echo = FALSE}
# creating an empty vector to store the accuracy of each iteration
acc.cart.cv <- numeric(10) 

for (i in 1:10){
  cart.cv <- rpart(response~., data = train.list[[i]]) # original tree
  
  # Tree to be prune at: 
  cp.pruned <- cart.cv$cptable[(
    min(which(cart.cv$cptable[, ncol(cart.cv$cptable) - 1] < 
                cart.cv$cptable[nrow(cart.cv$cptable), 
                                   ncol(cart.cv$cptable)] + 
                cart.cv$cptable[nrow(cart.cv$cptable), 
                                   ncol(cart.cv$cptable) - 1]))), 1] 
  
  # the pruned tree for predictions
  cart.pruned.cv <- prune(cart.cv, cp = cp.pruned) 
  
  # making the predictions
  cart.pred.cv <- predict(cart.pruned.cv, newdata = test.list[[i]], type = "class") 
  
  # the confusion matrix
  tab.cart.cv <- table(test.list[[i]]$response, cart.pred.cv) 
  
  # the final accuracy
  acc.cart.cv[i] <- accuracy(tab.cart.cv) 
}
```

We can now extract what we are interested in:

```{r}
acc.cart.cv # the accuracies obtained on each testing set
mean(acc.cart.cv) # the average accuracy
sd(acc.cart.cv) # the standard deviation of the accuracies
```
 
Here, we have an average accuracy for the *CART* model which is equal to `r mean(acc.cart.cv)` and that has a standard deviation of `r sd(acc.cart.cv)`. We see that, using a cross-validation, the accuracy obtained differ from the one using only the testing/training set approach. However, it is of course still really close to the previous one and within a range of one standard deviation, which was also completely predictable since the original train and test sets were also chosen at random.

Now that we have seen in detail how the cross-validation works thanks to this hand-made code, we can prefer to use the caret package that will do the work for us. Defining *train_control*, we will be able to use the same split between testing and training set for all the models. We will thus be able to conclude that differences in the accuracy will indeed be the consequence of the predictive capabilities of the model, and not from a "bad" repartition of the instances in the two sets.  

Let's run the cross-validation on each model that we previously tuned. 

```{r, results = 'hide'}
set.seed(1)
train_control <- trainControl(method = "cv", number = 10)

rpart_cv <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 method = "rpart1SE")

nnet_cv <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = 
                   data.frame(
                     size = nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$size,
                     decay = nnet_fit$results[which.max(nnet_fit$results$Accuracy),]$decay),
                 MaxNWts = 3000,
                 trace = FALSE,
                 method = "nnet")

svm_cv <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = data.frame(
                   C = svm_fit$results[which.max(svm_fit$results$Accuracy),]$C),
                 method = "svmRadialCost")

knn_cv <- train(form = response~ .,
                 data = cred,
                 trControl = train_control,
                 tuneGrid = data.frame(
                   k = knn_fit$results[which.max(knn_fit$results$Accuracy),]$k),
                 method = "knn",
                 preProcess = c("center", "scale"))

rf_cv <- train(form = response ~ .,
                 data = cred,
                 method = "rf",
                 ntree = 200, 
                 tuneGrid = data.frame(
                   mtry=rf_fit$results[which.max(rf_fit$results$Accuracy),]$mtry),
                 preProcess = "range",
                 trace = FALSE,
                 trControl = train_control)

boo_cv <- train(form = response ~ .,
                 data = cred,
                 method = "gbm",
                 tuneGrid = data.frame(
                 shrinkage = boo_fit$results[which.max(boo_fit$results$Accuracy),]$shrinkage,
                 n.trees = boo_fit$results[which.max(boo_fit$results$Accuracy),]$n.trees, 
                 interaction.depth = 1,
                 n.minobsinnode = 10),
                 trControl = train_control)
```

Now that all the models are built, it is possible to extract all their relevant information, to analyze their results and to opt for a specific model.

# Conclusion {#CCL}

## Results analysis and discussion

The first thing that we can do is to compute the accuracies of all of our models.

```{r, echo = FALSE}
accuracies <- data.frame(RPART = rpart_cv$results$Accuracy, 
                         NNET = nnet_cv$results$Accuracy,
                         SVM = svm_cv$results$Accuracy, 
                         KNN = knn_cv$results$Accuracy, 
                         RF = rf_cv$results$Accuracy, 
                         Boosting = boo_cv$results$Accuracy)

accuracies %>% kable(caption = "Accuracies of the different models",
                     col.names = c("Rpart", "NNET", "SVM",
                                   "KNN", "Random Forest", "Boosting")) %>% 
  column_spec(1, width = "6em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em") %>%
  column_spec(4, width = "6em") %>%
  column_spec(5, width = "6em") %>%
  column_spec(6, width = "6em")

```


Based on these measures of accuracy only, we can see that the model providing the best accuracy is the `r names(which.max(accuracies))`.  
We have to mention that these results are close to 0.75. They are not exceptional considering the repartition of our initial data. Indeed, in our initial database, there are 70% of "good" clients and only 30% of "bad" clients. Therefore, using a naive approach predicting "good" for everyone, we would already have had an accuracy of 0.7. Our analysis therefore only help us to improve our performance from 5 points of percentage.  
However, we have to mention that the improvement for the bank is still enormous as, using the naive approach that we suggested, credits would be accorded to all of the "bad" customers which could have dramatic consequences for the bank.  
Our models consider the individual characteristics of all of the clients and make a decision individually. Therefore, we have less *False Positives*, meaning that we are able to better detect the clients that are qualified as "bad" and to which the bank doesn't want to rent money as there is a high risk of not reimbursing the credit.  
Indeed, giving a credit to a client that will not reimburse it has much more dramatic consequences (the bank will loose all or only a part of the rented money) as not giving a credit to someone that would have reimburse it (the bank would only "not win" the interests).   
More specifically, in our case, the *sensitivity* (probability of predicting "bad" when the client is indeed a "bad" one)  is more important than the *specificity* (probability of predicting "good for a client that is indeed "good").     
Going further into that direction of having a particular focus at the clients that may not reimburse the money, we can look at the confusion matrices of each model rather than focusing only at the accuracy of each of them.  


```{r, echo = FALSE, results = 'asis'}
models <- c("rpart_cv", "nnet_cv", "svm_cv" ,"knn_cv", "rf_cv", "boo_cv")


for (i in 1:length(models)) {
print(confusionMatrix(models[i] %>% get)$table %>% 
        kable(caption = paste("Confusion matrix for the", models[i] , "model"),
                   col.names = c("Real bad", "Real good")) %>%
  kable_styling(
    bootstrap_options = c("striped", "hover", "condensed"),
    full_width = F,
    position = "left") %>%
  column_spec(1, border_right = T, width = "5em") %>%
  column_spec(2, width = "6em") %>%
  column_spec(3, width = "6em"))
}
```

Based on these matrices, we will have to have a particular look at the elements on the bottom left hand corner as those are the *False Positive*, meaning that these instances are predicted as "good" but are in fact "bad" and will not reimburse the credit.  
More specifically, we should look at the sensitivity of each model that will tell us, among the clients that are indeed bad, the probability that they are categorized as bad.  
To do so, we created the two following functions to test the sensitivity of our models based on their confusion matrices.

```{r}
sensitivity <- function(x) {
  x[1,1]/(x[1,1] + x[2,1])
}
specificity <- function(x) {
  x[2,2]/(x[2,2] + x[1,2])
}
```

We apply them to the matrices to get the most usefull informations that we present in the following tables:  

```{r, results = 'asis', echo = FALSE}
for (i in 1:length(models)) {
  print(data.frame(
    Sensitivity = confusionMatrix(models[i] %>% get)$table %>% sensitivity,
    Specificity = confusionMatrix(models[i] %>% get)$table %>% specificity,
    Accuracy = confusionMatrix(models[i] %>% get)$table %>% accuracy,
    FP_rate = confusionMatrix(models[i] %>% get)$table[2,1]
  ) 
  %>% 
    kable(caption = paste("Main criterion of the", models[i], "model")) %>%
    kable_styling(
      bootstrap_options = c("striped", "hover", "condensed"),
      full_width = F,
      position = "left")
  )
}
```

<hr>
After having presented some of the criterion that might be considered in order to select the final model that will be used for the predictions in the future, we underlined the fact that accuracy, false positive rate and sensitivity are particularily important.  

Thus, considering these different aspects, the **boosting model** seems to be an excellent choice. Indeed, the accuracy is almost equivalent to the best one and is not statistically significantly different from it. However, the sensitivity linked to the boosting model is much more satisfying and outperforms the other models. We can make the same conclusion about the false positive rate which is lower.  
As it is a really important aspect of our analysis, these aspect will tend to prime over an accuracy. 

Therefore, considering all these measures and what has been said before, we would recommend the final user to go for the boosting model.

## Going further

At this point, we could find a performant model that leads to a high accuracy, which has been the main criterion all over our analysis. The problem is that this model doesn't predict the "bad" customers well and we could even say that, within the "bad" customer, we have a random predictor as we can only reach a sensitivity of 0.5.  
Therefore, considering the concepts that we presented in the last section, it could be interesting to reconduct this analysis using other criterion, like a weighted accuracy giving more weights to the "bad" customers.  
Working in this way with a weighted accuracy, all the tuning during our process of selecting the best models would potentially lead to new parameters and to better predict the "bad" instances in which we are particularily interested in.  
Another approach that could be used is to separate the inital dataset into two different sets with the same number of "good" and "bad" customers (300 of each) is to change the *a priori* of predicting the most represented class. Using this method, the different build models will not favorize the "good" outcome which might increase the predictive capabilities of the prediction of "bad" customers.  

# References




